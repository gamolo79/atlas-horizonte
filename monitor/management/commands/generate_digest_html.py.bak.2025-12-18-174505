from __future__ import annotations

import json
from datetime import date

from django.core.management.base import BaseCommand
from django.db import transaction
from django.utils.html import escape

from monitor.models import Digest, DigestItem, DigestSection, StoryCluster


def _count_sentiments(mentions):
    pos = neu = neg = 0
    total = 0
    for m in mentions:
        s = getattr(m.article, "sentiment", None)
        if not s:
            continue
        total += 1
        label = (getattr(s, "label", "") or "").lower()
        if label == "positive":
            pos += 1
        elif label == "negative":
            neg += 1
        else:
            neu += 1
    return pos, neu, neg, total


def _count_content_types(mentions):
    info = opinion = 0
    total = 0
    for m in mentions:
        c = getattr(m.article, "content_classification", None)
        if not c:
            continue
        total += 1
        label = (getattr(c, "label", "") or "").lower()
        # aceptamos varios nombres por si cambiaste choices
        if label in ("opinion", "opinión", "opinion_piece"):
            opinion += 1
        else:
            info += 1
    return info, opinion, total


class Command(BaseCommand):
    help = "Generate daily HTML + JSON digest with editorial sections, volume, sentiment and clickable sources."

    def add_arguments(self, parser):
        parser.add_argument("--date", type=str, help="YYYY-MM-DD (default: today)")
        parser.add_argument("--title", type=str, default="Síntesis diaria de prensa")
        parser.add_argument("--top", type=int, default=5, help="How many stories go to Priority section")

    def handle(self, *args, **opts):
        target_date_str = opts["date"]
        title = opts["title"]
        top_n = opts["top"]

        if target_date_str:
            y, m, d = map(int, target_date_str.split("-"))
            target_date = date(y, m, d)
        else:
            target_date = date.today()

        clusters = list(
            StoryCluster.objects.all()
            .order_by("-created_at")
            .prefetch_related(
                "mentions__media_outlet",
                "mentions__article",
                "mentions__article__sentiment",
                "mentions__article__content_classification",
            )
        )

        if not clusters:
            self.stdout.write(self.style.WARNING("No hay historias para generar síntesis."))
            return

        def volume(c):
            return len(list(c.mentions.all()))

        clusters_sorted = sorted(clusters, key=volume, reverse=True)
        priority = clusters_sorted[:top_n]
        rest = clusters_sorted[top_n:]

        with transaction.atomic():
            digest, _ = Digest.objects.update_or_create(
                date=target_date,
                title=title,
                defaults={"html_content": "", "json_content": {}},
            )

            digest.sections.all().delete()

            sec_priority = DigestSection.objects.create(
                digest=digest,
                section_type=DigestSection.SectionType.PRIORITY,
                label="Enfoque / Prioridad",
                order=1,
            )
            sec_general = DigestSection.objects.create(
                digest=digest,
                section_type=DigestSection.SectionType.GENERAL,
                label="Notas generales",
                order=2,
            )

            for i, c in enumerate(priority, start=1):
                DigestItem.objects.create(section=sec_priority, cluster=c, order=i)
            for i, c in enumerate(rest, start=1):
                DigestItem.objects.create(section=sec_general, cluster=c, order=i)

            # ---- HTML
            html = []
            html.append(f"<h1>{escape(title)}</h1>")
            html.append(f"<p><strong>Fecha:</strong> {target_date}</p>")

            digest_json = {
                "title": title,
                "date": str(target_date),
                "sections": [],
            }

            for sec in digest.sections.all().order_by("order"):
                html.append(f"<h2>{escape(sec.label)}</h2>")

                sec_json = {
                    "label": sec.label,
                    "section_type": sec.section_type,
                    "items": [],
                }

                items = sec.items.select_related("cluster").order_by("order")
                for item in items:
                    cluster = item.cluster
                    headline = item.custom_headline or cluster.headline
                    lead = item.custom_lead or (cluster.lead or "")
                    mentions = list(
                        cluster.mentions.select_related("media_outlet", "article").all()
                    )
                    vol = len(mentions)

                    pos, neu, neg, s_total = _count_sentiments(mentions)
                    info, opinion, c_total = _count_content_types(mentions)

                    html.append("<hr>")
                    html.append(f"<h3>{escape(headline)}</h3>")
                    html.append(f"<p><strong>Volumen:</strong> {vol} notas</p>")

                    if s_total > 0:
                        html.append(
                            f"<p><strong>Sentimiento:</strong> "
                            f"{pos} positivo · {neu} neutro · {neg} negativo (de {s_total})</p>"
                        )

                    if c_total > 0:
                        html.append(
                            f"<p><strong>Tipo de texto:</strong> "
                            f"{info} informativo · {opinion} opinión (de {c_total})</p>"
                        )

                    if lead:
                        html.append(f"<p>{escape(lead)}</p>")

                    # Chips (en lista) con link a la URL original
                    html.append("<ul>")
                    for m in mentions:
                        outlet = m.media_outlet.name
                        url = m.article.url
                        html.append(
                            f'<li><a href="{escape(url)}" target="_blank" rel="noopener noreferrer">'
                            f'{escape(outlet)}</a></li>'
                        )
                    html.append("</ul>")

                    sec_json["items"].append(
                        {
                            "cluster_id": cluster.id,
                            "headline": headline,
                            "lead": lead,
                            "volume": vol,
                            "sentiment": {"positive": pos, "neutral": neu, "negative": neg, "total": s_total},
                            "content_type": {"informative": info, "opinion": opinion, "total": c_total},
                            "mentions": [
                                {
                                    "media_outlet": mm.media_outlet.name,
                                    "url": mm.article.url,
                                    "article_id": mm.article_id,
                                }
                                for mm in mentions
                            ],
                        }
                    )

                digest_json["sections"].append(sec_json)

            digest.html_content = "\n".join(html)
            digest.json_content = digest_json
            digest.save(update_fields=["html_content", "json_content"])

        self.stdout.write(self.style.SUCCESS("Digest creado/actualizado correctamente (HTML + JSON)"))
